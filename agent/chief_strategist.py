import json
import sys
import os
import pandas as pd
from datetime import datetime
from typing import Dict, Any, List

# 添加项目根目录到Python路径
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from data_fetcher import get_stock_data, stock_individual_fund_flow, IndexDataFetcher
from ai_analyzer import askDeepSeek

# 检查是否启用debug模式
DEBUG = os.environ.get('DEBUG', '').lower() in ('true', '1', 'yes')


class ChiefStrategistAgent:
    """
    总参谋长Agent - 整合5位专家的独立分析报告，输出最终交易策略
    """
    
    def __init__(self):
        self.name = "总参谋长"
        self.required_roles = [
            "阶段猎手", "量能侦探", "目标工程师", "强度指挥官", "弹簧猎人"
        ]
        
    def analyze(self, expert_reports: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        执行总参谋长分析
        
        Args:
            expert_reports: 5位专家的分析报告列表
            
        Returns:
            整合后的交易策略
        """
        # 输入校验
        validation_result = self._validate_reports(expert_reports)
        if not validation_result["valid"]:
            return {
                "错误": validation_result["error"],
                "综合信号": "中性",
                "共识强度": 0,
                "主要分歧": [],
                "综合止损位": "¥0.00",
                "综合目标价": "¥0.00",
                "建议仓位": "0%",
                "最终置信度": 0,
                "执行条件": [],
                "观察清单": [],
                "_debug_reasoning": [f"输入校验失败: {validation_result['error']}"]
            }
        
        # 构造prompt
        prompt = self._build_prompt(expert_reports)
        
        # 调用AI分析
        # 由于这是整合分析，不需要股票数据和资金流向数据
        analysis_result = askDeepSeek(
            stock_df=pd.DataFrame(),  # 传入空的DataFrame而不是None
            stock_fund_flow_df=pd.DataFrame(),  # 传入空的DataFrame而不是None
            stock_code="整合分析",
            prompt_content=prompt
        )
        
        # Debug模式下打印AI返回结果
        if DEBUG:
            print(f"[DEBUG] 总参谋长AI返回结果: {analysis_result}")
        
        # 解析结果
        return self._parse_analysis_result(analysis_result)
    
    def _validate_reports(self, expert_reports: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        验证专家报告的完整性和正确性
        
        Args:
            expert_reports: 专家报告列表
            
        Returns:
            验证结果
        """
        # 检查报告数量
        if not expert_reports:
            return {"valid": False, "error": "未提供专家报告"}
            
        if len(expert_reports) != 5:
            return {"valid": False, "error": f"专家报告数量不正确，期望5个，实际{len(expert_reports)}个"}
        
        # 检查每个报告是否为字典类型，如果不是则尝试解析
        processed_reports = []
        for i, report in enumerate(expert_reports):
            if isinstance(report, str):
                # 如果是字符串，尝试解析为JSON
                try:
                    import json
                    parsed_report = json.loads(report)
                    processed_reports.append(parsed_report)
                except:
                    # 如果解析失败，保持原样
                    processed_reports.append(report)
            else:
                processed_reports.append(report)
        
        # 更新expert_reports为处理后的报告
        expert_reports = processed_reports
        
        # 检查是否包含全部必要角色
        provided_roles = []
        for report in expert_reports:
            if isinstance(report, dict):
                provided_roles.append(report.get("角色", ""))
            else:
                # 如果不是字典，可能是AI的原始字符串响应
                provided_roles.append("")
        
        missing_roles = set(self.required_roles) - set(provided_roles)
        
        if missing_roles:
            return {"valid": False, "error": f"缺少以下角色的报告: {', '.join(missing_roles)}"}
        
        # 检查每个报告是否包含必要字段
        required_fields = ["信号", "置信度"]
        for report in expert_reports:
            if isinstance(report, dict):
                role = report.get("角色", "")
                missing_fields = [field for field in required_fields if field not in report]
                if missing_fields:
                    return {"valid": False, "error": f"{role}报告缺少必要字段: {', '.join(missing_fields)}"}
            # 如果不是字典类型，跳过检查，因为这是AI的原始响应
        
        return {"valid": True, "error": ""}
    
    def _build_prompt(self, expert_reports: List[Dict[str, Any]]) -> str:
        """
        构建整合分析prompt
        """
        # 准备专家报告字符串
        reports_str = ""
        for i, report in enumerate(expert_reports, 1):
            reports_str += f"\n--- 专家{i}报告 ---\n"
            if isinstance(report, dict):
                reports_str += json.dumps(report, ensure_ascii=False, indent=2)
            else:
                # 如果是字符串（AI的原始响应），直接添加
                reports_str += str(report)
            reports_str += "\n"
        
        prompt = f'''你是一位威科夫首席策略官，代号【总参谋长】，负责整合5位专家（阶段猎手、量能侦探、目标工程师、强度指挥官、弹簧猎人）的独立分析报告，输出具备可执行性、风险可控、逻辑可追溯的最终交易策略，并以json格式返回结果。

以下是各位专家的独立分析报告：

{reports_str}

---

### ⚠️ 输入校验要求（第一步必须执行）：
- 检查是否包含全部5个角色报告（角色字段必须匹配：阶段猎手、量能侦探、目标工程师、强度指挥官、弹簧猎人）
- 检查每个报告是否包含必要字段（如"信号"、"置信度"、"止损位"等）
- 若缺失或格式错误 → 输出错误信息并终止，不生成策略

---

```markdown
【系统指令】
■ 角色：综合分析师
■ 职责：仲裁专家冲突，生成最终信号、仓位、执行条件
■ 输入权限：
  - 所有专家完整报告（阶段猎手、量能侦探、弹簧猎人、目标工程师、强度指挥官）
■ 输出权限（仅可写入以下字段）：
  - 角色
  - 信号
  - 共识强度
  - 高风险冲突
  - 冲突详情
  - 止损位
  - 目标价
  - 建议仓位
  - 执行前提
  - 观察清单
  - 理由
  - _debug_reasoning
■ 行为规范：
  1. 必须按7步编号推理（共识→冲突→信号→止损→目标→仓位→执行条件）
  2. 每步必须引用专家名.字段=值（如 目标工程师.可执行=true）
  3. 若任一专家报告缺失，返回 {"错误": "专家报告缺失", "缺失专家": [...]}
  4. 输出必须为合法JSON，字段名严格对齐Schema。
■ 禁止行为：
  - 禁止自行计算目标价或止损位（必须引用专家值）
  - 禁止在高风险冲突=true时输出看涨/看跌信号（必须中性）
  - 禁止忽略“信号中性时仓位强制归零”规则
```

###【综合分析师 · 输入数据完整性检查】

```markdown
【数据安检】
■ 必需字段：
  - 阶段猎手完整报告（含所有输出字段）
  - 量能侦探完整报告
  - 弹簧猎人完整报告
  - 目标工程师完整报告
  - 强度指挥官完整报告

■ 格式校验：
  - 每份报告必须为合法JSON
  - 必须包含"角色"、"信号"、"置信度"字段
  - 无"错误"字段（即所有专家必须成功执行）

■ 逻辑校验：
  - 专家角色名必须匹配（如"阶段猎手"≠"阶段猎手v2"）
  - 信号值必须为["看涨", "看跌", "中性"]

■ 若任一专家报告缺失或含错误：
→ 立即返回 {"错误": "专家报告缺失或含错误", "缺失专家": ["弹簧猎人"], "角色": "综合分析师"}
```


### 🧩 任务要求（请严格按以下编号步骤推理）

请按 **7大主步骤 + 子步骤编号** 逐行推理，每步必须：
- 引用具体专家报告字段（格式：专家名.字段=值，如 阶段猎手.阶段评分=4）
- 标注影响的输出字段（→ 输出字段：XXX）
- 不得合并、跳跃或省略

推理过程将用于内部校验与自动化解析，请确保机器可读。

---

#### 📊 步骤1：统计信号共识与分歧 + 计算共识强度

> 统计5位专家"信号"字段：
> - 看涨 / 看跌 / 中性 各出现次数
> - 共识强度 = 最高票数（如3看涨 → 共识强度=3）
> - 标注分歧专家及原始信号（如"量能侦探=看跌，弹簧猎人=看涨"）  
> → 输出字段：`共识强度`, `信号分布`, `理由`

```markdown
步骤1.1: 阶段猎手.信号="看涨"
步骤1.2: 量能侦探.信号="中性"（因风险警告=true强制覆盖）
步骤1.3: 目标工程师.信号="看涨"
步骤1.4: 强度指挥官.信号="看涨"
步骤1.5: 弹簧猎人.信号="看涨"
步骤1.6: 信号分布：看涨=4，中性=1，看跌=0 → 共识强度=4
步骤1.7: 分歧专家：量能侦探（中性） vs 其他4人（看涨）
→ 输出字段：共识强度=4, 信号分布={"看涨":4,"中性":1,"看跌":0}, 理由="4/5专家看涨，仅量能侦探因风险警告中性"
```

---

#### ⚖️ 步骤2：识别高风险冲突点 + 冲突标记

> 检查是否存在以下冲突（任一存在即标记高风险=true）：
> 1. 【目标工程师】"可执行=false" 但 其他≥3人看涨  
> 2. 【量能侦探】"风险警告=true" 但 【弹簧猎人】"事件验证=true"  
> 3. 【阶段猎手】阶段评分<3 但 【目标工程师】K值>2.5  
> ➤ 引用冲突专家名称 + 关键字段值  
> → 输出字段：`高风险冲突`, `冲突详情`, `理由`

```markdown
步骤2.1: 检查冲突1：目标工程师.可执行=true → 不触发
步骤2.2: 检查冲突2：量能侦探.风险警告=true 且 弹簧猎人.事件验证=true → 冲突成立
步骤2.3: 检查冲突3：阶段猎手.阶段评分=4 ≥3 → 不触发
步骤2.4: 高风险冲突=true，冲突详情=["量能侦探风险警告与弹簧猎人事件验证冲突"]
→ 输出字段：高风险冲突=true, 冲突详情=["量能侦探.风险警告=true vs 弹簧猎人.事件验证=true"], 理由补充"存在量能风险与结构成功冲突"
```

---

#### 🎯 步骤3：确定综合信号 + 仲裁规则

> 规则：
> - 若共识强度 ≥3 且 无高风险冲突 → 采纳共识方向  
> - 否则 → 综合信号 = "中性"  
> ➤ 引用采纳/拒绝的具体依据  
> → 输出字段：`信号`, `理由`

```markdown
步骤3.1: 共识强度=4 ≥3 → 满足
步骤3.2: 但高风险冲突=true → 触发“否则”规则
步骤3.3: 综合信号=中性（强制覆盖共识）
→ 输出字段：信号="中性", 理由="虽4人看涨，但存在量能风险与结构成功冲突，强制中性"
```

---

#### 🛑 步骤4：计算综合止损位 + 取最紧原则

> 取所有专家报告中"止损位"的最小值（最紧止损）  
> ➤ 列出各专家止损位并标注来源（格式：专家名: ¥XX.XX）  
> → 输出字段：`止损位`, `理由`

```markdown
步骤4.1: 阶段猎手.止损位="¥27.78"
步骤4.2: 量能侦探无止损位 → 忽略
步骤4.3: 目标工程师.止损价="¥32.45"（引用阶段猎手）
步骤4.4: 强度指挥官无止损位 → 忽略
步骤4.5: 弹簧猎人无独立止损位 → 忽略
步骤4.6: 最小值=¥27.78（阶段猎手提供）
→ 输出字段：止损位="¥27.78", 理由="取阶段猎手提供的最紧止损位"
```

---

#### 📈 步骤5：采纳或降级综合目标价 + 置信度校验

> 仅采纳【目标工程师】的目标价，但需满足：
> - 其"置信度" ≥ 70 → 直接采纳  
> - 其"置信度" < 70 → 降级处理：目标价 = 突破点 + (区间高度 × 1.5) 或 放弃目标价（标注"目标不可信"）  
> ➤ 展示原始目标价、置信度、是否降级、最终采用值  
> → 输出字段：`目标价`, `理由`

```markdown
步骤5.1: 目标工程师.目标价="¥51.75"
步骤5.2: 目标工程师.置信度=95 ≥70 → 满足采纳条件
步骤5.3: 但综合信号=中性 → 目标价仅作参考，标注"（信号中性，目标仅供参考）"
步骤5.4: 最终目标价="¥51.75（信号中性，目标仅供参考）"
→ 输出字段：目标价="¥51.75（信号中性，目标仅供参考）", 理由="置信度95达标，但综合信号中性故仅参考"
```

---

#### 💰 步骤6：计算建议仓位 + 公式透明化

> 公式：  
> `建议仓位(%) = 共识强度 × 市场环境系数 × 账户风险系数`  
> - 市场环境系数 = 1.0（若【强度指挥官】板块同步=true 且 无大盘降级）否则 0.5  
> - 账户风险系数 = 0.01（默认1%，可外部传入覆盖）  
> ➤ 展示中间计算值（如"3 × 1.0 × 0.01 = 3%"）  
> → 输出字段：`建议仓位`, `理由`

```markdown
步骤6.1: 共识强度=4
步骤6.2: 强度指挥官.板块同步=false（个股独立启动）→ 市场环境系数=0.5
步骤6.3: 账户风险系数=0.01（默认）
步骤6.4: 建议仓位=4 × 0.5 × 0.01 = 0.02 → 2%
步骤6.5: 因综合信号=中性 → 实际建议仓位=0%（强制归零）
→ 输出字段：建议仓位="0%（信号中性强制归零）", 理由="计算值2%，但综合信号中性强制归零"
```

---

#### 🔍 步骤7：生成执行条件与观察清单 + 数据溯源

> 基于各专家"理由"与"_debug_reasoning"，提取：
> - 3项最关键执行前提（如"需放量突破¥XX"）  
> - 3项关键观察指标（如"若量能<XX万手则放弃"、"若3日内未突破则止损"）  
> ➤ 每项必须标注来源专家（如“←阶段猎手”）  
> → 输出字段：`执行前提`, `观察清单`, `_debug_reasoning`

```markdown
步骤7.1: 执行前提1="需确认量能侦探风险警告解除（如出现二次测试） ←量能侦探"
步骤7.2: 执行前提2="需弹簧猎人确认无失败风险（如3日内不破¥28.20） ←弹簧猎人"
步骤7.3: 执行前提3="需目标工程师盈亏比维持>2.5 ←目标工程师"
步骤7.4: 观察清单1="若3日内量能<14.2万（均量）则放弃 ←量能侦探"
步骤7.5: 观察清单2="若价格跌破¥28.20（弹簧低点）立即止损 ←弹簧猎人"
步骤7.6: 观察清单3="若强度指挥官RS<1.0则降仓 ←强度指挥官"
→ 输出字段：执行前提=["..."], 观察清单=["..."], _debug_reasoning=[...]
```

### 置信度校准公式
```markdown
■ 不计算自身置信度

■ 使用规则：
- 若任一专家经校准后置信度<60 → 在“理由”中提示“低置信度专家：XXX”
- 若高风险冲突=true → 强制信号=中性，无视专家置信度
- 建议仓位计算中，可引入“加权共识强度”（未来版本）

■ 输出要求：
在 _debug_reasoning 中记录：
"目标工程师校准后置信度=42（<60，低可信）"
"强度指挥官置信度=70（达标）"
```
---

### 🔧 Schema定义

```json
{{
  "type": "object",
  "properties": {{
    "角色": {{"type": "string", "const": "综合分析师"}},
    "最终信号": {{"type": "string", "enum": ["看涨", "看跌", "中性"]}},
    "冲突解决": {{"type": "string"}},
    "仓位建议": {{"type": "string", "pattern": "^(0%|50%|100%)$"}},
    "关键调整": {{
      "type": "array",
      "items": {{"type": "string"}}
    }},
    "最终置信度": {{"type": "integer", "minimum": 0, "maximum": 100}},
    "理由": {{"type": "string", "minLength": 10}},
    "_debug_reasoning": {{
      "type": "array",
      "items": {{"type": "string"}},
      "minItems": 3
    }}
  }},
  "required": [
    "角色", "最终信号", "冲突解决", "仓位建议", "关键调整",
    "最终置信度", "理由", "_debug_reasoning"
  ],
  "additionalProperties": false
}}
```

### 📜 系统指令

> 【系统指令】你是综合分析师，必须遵守：1）目标工程师可执行=false → 仓位0%；2）大盘派发 → 仓位0%；3）风险警告=true → 仓位50%。输出严格JSON。

### 🧪 案例输出示范

```json
{{
  "角色": "综合分析师",
  "最终信号": "中性",
  "冲突解决": "盈亏比不足强制放弃",
  "仓位建议": "0%",
  "关键调整": ["无视其他看涨信号，遵守目标工程师可执行=false"],
  "最终置信度": 60,
  "理由": "目标工程师因盈亏比1.8<2.5判定不可执行，系统规则优先级最高。",
  "_debug_reasoning": [
    "步骤1: 目标工程师可执行=false → 最高优先级",
    "步骤2: 强制中性，仓位0%",
    "步骤3: 其他专家信号忽略"
  ]
}}
```

## 案例1：5专家共识无冲突（满仓执行 · 半导体）

````
### 输入：
标的：中微公司 (688012)
阶段猎手：看涨，阶段评分4，置信度88  
量能侦探：看涨，比率1.3，风险警告=false，置信度92  
目标工程师：看涨，盈亏比5.3，可执行=true，置信度90  
强度指挥官：看涨，RS=9.0，评分维持，置信度98  
弹簧猎人：看涨，事件验证=true，失败风险=false，置信度95  
大盘状态：沪深300吸筹阶段（阶段猎手提供）

### 输出：
{{
  "角色": "综合分析师",
  "最终信号": "看涨",
  "冲突解决": "无冲突",
  "仓位建议": "100%",
  "关键调整": [],
  "最终置信度": 93,
  "理由": "5专家100%看涨共识，无任何风险警告，大盘同步，盈亏比>5.0，建议满仓执行。",
  "_debug_reasoning": [
    "步骤1: 5专家信号全部看涨 → 无冲突",
    "步骤2: 量能侦探风险警告=false，弹簧猎人失败风险=false → 无风险",
    "步骤3: 目标工程师盈亏比5.3>3.0 → 可执行",
    "步骤4: 强度指挥官RS=9.0，大盘吸筹 → 无降级",
    "步骤5: 最终置信度=平均(88,92,90,98,95)=92.6 → 93，仓位100%"
  ]
}}
```

> 💡 规则：**5专家一致看涨 + 无风险警告 + 盈亏比>3.0 → 100%仓位**。

---

## 案例2：3看涨但高风险警告（降仓至50% · 白酒）

````
### 输入：
标的：泸州老窖 (000568)
阶段猎手：看涨，阶段评分4，置信度80  
量能侦探：看跌，比率0.0044，风险警告=true，置信度85 ← 冲突源  
目标工程师：看涨，盈亏比4.0，可执行=true，置信度88  
强度指挥官：看涨，RS=2.0，评分维持，置信度82  
弹簧猎人：看涨，事件验证=true，失败风险=false，置信度85  
大盘状态：沪深300吸筹阶段

### 输出：
{{
  "角色": "综合分析师",
  "最终信号": "看涨",
  "冲突解决": "量能风险警告降仓",
  "仓位建议": "50%",
  "关键调整": ["忽略量能侦探看跌信号，但遵守其风险警告"],
  "最终置信度": 78,
  "理由": "量能侦探发出高风险警告（比率0.0044），虽3专家看涨，但必须降仓50%以控制风险。",
  "_debug_reasoning": [
    "步骤1: 3专家看涨（阶段、目标、强度），1专家看跌（量能），1中性（弹簧看涨）→ 主要冲突=量能风险",
    "步骤2: 量能侦探风险警告=true → 无论其信号如何，必须降仓",
    "步骤3: 其他条件健康（盈亏比4.0，RS=2.0）→ 不放弃交易",
    "步骤4: 降仓规则：有风险警告 → 仓位=50%",
    "步骤5: 置信度=加权平均（看涨专家80,88,82,85）但降5分因风险 → 78"
  ]
}}
```

> 💡 关键规则：**只要任一专家发出“风险警告=true”，仓位强制降至50%，无视信号方向**。

---

## 案例3：目标工程师盈亏比不足（放弃交易 · 医药）

````
### 输入：
标的：长春高新 (000661)
阶段猎手：看涨，阶段评分5，置信度90  
量能侦探：看涨，比率1.5，风险警告=false，置信度85  
目标工程师：中性，盈亏比1.8，可执行=false，置信度65 ← 冲突源  
强度指挥官：看涨，RS=3.0，评分维持，置信度88  
弹簧猎人：看涨，事件验证=true，失败风险=false，置信度90  
大盘状态：沪深300吸筹阶段

### 输出：
{{
  "角色": "综合分析师",
  "最终信号": "中性",
  "冲突解决": "盈亏比不足强制放弃",
  "仓位建议": "0%",
  "关键调整": ["无视其他看涨信号，遵守目标工程师可执行=false"],
  "最终置信度": 60,
  "理由": "目标工程师因盈亏比1.8<2.5判定不可执行，系统规则优先级最高，强制空仓。",
  "_debug_reasoning": [
    "步骤1: 4专家看涨，1专家中性（目标）→ 冲突=目标工程师可执行=false",
    "步骤2: 系统规则：目标工程师可执行=false → 最终信号强制中性，仓位0%",
    "步骤3: 无视其他高置信度信号（阶段90，弹簧90）",
    "步骤4: 无仓位，置信度取目标工程师65，但因强制放弃降5分 → 60",
    "步骤5: 理由强调‘盈亏比不足’为系统硬规则"
  ]
}}
```

> 💡 系统铁律：**目标工程师“可执行=false” → 最终信号强制中性，仓位0%**。

---

## 案例4：大盘派发阶段强制中性（无视个股强势 · 消费白马）

````
### 输入：
标的：贵州茅台 (600519)
阶段猎手：看涨，阶段评分4，置信度85  
量能侦探：看涨，比率1.8，风险警告=false，置信度90  
目标工程师：看涨，盈亏比6.0，可执行=true，置信度92  
强度指挥官：中性，RS=-4.0，评分降级，置信度55 ← 因大盘派发  
弹簧猎人：看涨，事件验证=true，失败风险=false，置信度88  
大盘状态：沪深300派发阶段（阶段猎手提供）← 冲突源

### 输出：
{{
  "角色": "综合分析师",
  "最终信号": "中性",
  "冲突解决": "大盘派发强制降级",
  "仓位建议": "0%",
  "关键调整": ["无视所有看涨信号，遵守大盘派发规则"],
  "最终置信度": 50,
  "理由": "大盘处于派发阶段，系统规则优先级最高，无论个股多强，强制空仓避险。",
  "_debug_reasoning": [
    "步骤1: 4专家看涨，1专家中性（强度因大盘）→ 冲突=大盘状态",
    "步骤2: 系统规则：大盘派发阶段 → 最终信号强制中性，仓位0%",
    "步骤3: 无视目标工程师盈亏比6.0、量能侦探比率1.8等利好",
    "步骤4: 置信度取最低值（强度55）并降5分因系统强制 → 50",
    "步骤5: 理由强调‘大盘风险>个股机会’"
  ]
}}
```

> 💡 生存法则：**大盘派发阶段 → 一切个股信号作废，强制空仓**。

---

## 案例5：极端行情冲突（弹簧失败但量能健康 → 观望 · 券商）

````
### 输入：
标的：东方财富 (300059)
阶段猎手：看跌，阶段评分2，置信度75 ← 弹簧失败  
量能侦探：看涨，比率0.07，风险警告=false，置信度80 ← 缩量急跌豁免  
目标工程师：看涨，盈亏比3.5，可执行=true，置信度78  
强度指挥官：看跌，RS=0.5，评分降级，置信度60 ← 板块拖累  
弹簧猎人：看跌，事件验证=false，失败风险=true，置信度90 ← 破前低  
大盘状态：沪深300吸筹阶段

### 输出：
{{
  "角色": "综合分析师",
  "最终信号": "中性",
  "冲突解决": "弹簧失败优先级最高，但量能健康 → 观望",
  "仓位建议": "0%",
  "关键调整": ["弹簧失败风险=true强制看跌，但量能侦探豁免缩量急跌 → 不执行做空"],
  "最终置信度": 65,
  "理由": "弹簧猎人失败风险=true本应强制看跌，但量能侦探判定缩量急跌属健康洗盘，冲突无法解决，建议观望不交易。",
  "_debug_reasoning": [
    "步骤1: 2看跌（阶段、弹簧），2看涨（量能、目标），1中性（强度）→ 核心冲突=弹簧失败 vs 量能健康",
    "步骤2: 弹簧猎人失败风险=true → 通常强制看跌",
    "步骤3: 但量能侦探判定缩量急跌（比率0.07）属健康洗盘，豁免风险警告",
    "步骤4: 冲突无法调和 → 最终信号中性，仓位0%",
    "步骤5: 置信度取平均(75,80,78,60,90)=76.6，但因冲突降10分 → 65"
  ]
}}
```

'''
        return prompt
    
    def _parse_analysis_result(self, result: str) -> Dict[str, Any]:
        """
        解析分析结果
        """
        # 检查结果是否为空
        if not result or not result.strip():
            return {
                "综合信号": "中性",
                "共识强度": 0,
                "主要分歧": [],
                "综合止损位": "¥0.00",
                "综合目标价": "¥0.00",
                "建议仓位": "0%",
                "最终置信度": 50,
                "执行条件": [],
                "观察清单": [],
                "理由": "AI未返回有效分析结果",
                "_debug_reasoning": ["错误: AI返回结果为空"]
            }
        
        try:
            # 提取JSON部分
            if "```json" in result:
                json_str = result.split("```json")[1].split("```")[0]
            elif "```" in result:
                # 尝试处理其他代码块格式
                parts = result.split("```")
                if len(parts) >= 3:
                    json_str = parts[1]
                else:
                    json_str = result
            else:
                # 尝试直接解析
                json_str = result
            
            # 清理JSON字符串
            json_str = json_str.strip()
            
            # 检查是否为空
            if not json_str:
                return {
                    "综合信号": "中性",
                    "共识强度": 0,
                    "主要分歧": [],
                    "综合止损位": "¥0.00",
                    "综合目标价": "¥0.00",
                    "建议仓位": "0%",
                    "最终置信度": 50,
                    "执行条件": [],
                    "观察清单": [],
                    "理由": "AI未返回有效JSON数据",
                    "_debug_reasoning": ["错误: 提取的JSON字符串为空"]
                }
            
            return json.loads(json_str)
        except json.JSONDecodeError as e:
            # 如果解析失败，返回默认结构
            return {
                "综合信号": "中性",
                "共识强度": 0,
                "主要分歧": [],
                "综合止损位": "¥0.00",
                "综合目标价": "¥0.00",
                "建议仓位": "0%",
                "最终置信度": 50,
                "执行条件": [],
                "观察清单": [],
                "理由": f"解析AI返回的JSON数据时发生错误: {str(e)}",
                "_debug_reasoning": [f"JSON解析错误: {str(e)}", f"原始响应: {result[:500]}..."]
            }
        except Exception as e:
            # 其他异常处理
            return {
                "综合信号": "中性",
                "共识强度": 0,
                "主要分歧": [],
                "综合止损位": "¥0.00",
                "综合目标价": "¥0.00",
                "建议仓位": "0%",
                "最终置信度": 50,
                "执行条件": [],
                "观察清单": [],
                "理由": f"处理分析结果时发生未知错误: {str(e)}",
                "_debug_reasoning": [f"未知错误: {str(e)}", f"原始响应: {result[:500]}..."]
            }


def run_chief_strategist_agent(expert_reports: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    运行总参谋长agent
    
    Args:
        expert_reports: 5位专家的分析报告列表
        
    Returns:
        整合后的交易策略
    """
    agent = ChiefStrategistAgent()
    return agent.analyze(expert_reports)


def _create_sample_reports():
    """创建示例报告用于测试"""
    return [
        {
            "角色": "阶段猎手",
            "信号": "看涨",
            "置信度": 85,
            "阶段评分": 4,
            "关键结构": ["弹簧", "二次测试"],
            "大盘影响": False,
            "止损位": "¥15.20",
            "理由": "主力正在测试供应枯竭",
            "_debug_reasoning": ["步骤1: 识别为拉升阶段", "步骤2: 结构完整"]
        },
        {
            "角色": "量能侦探",
            "信号": "看涨",
            "置信度": 80,
            "努力结果比率": "1.8",
            "异常行为": [],
            "机构验证": "同步",
            "风险警告": False,
            "理由": "量价健康",
            "_debug_reasoning": ["步骤1: 报酬率=1.8 → 健康", "步骤3: 机构同步"]
        },
        {
            "角色": "目标工程师",
            "信号": "看涨",
            "置信度": 75,
            "因果空间": "¥10.00",
            "K值": 2.5,
            "目标价": "¥30.00",
            "盈亏比": "3.0",
            "可执行": True,
            "理由": "目标价合理",
            "_debug_reasoning": ["步骤3: 目标价=20.00+(10.00×2.5)=45.00", "步骤4: 盈亏比=3.0 → 可执行"]
        },
        {
            "角色": "强度指挥官",
            "信号": "看涨",
            "置信度": 70,
            "相对强度RS": 1.3,
            "板块同步": True,
            "资金流向": "净流入",
            "评分调整": "维持",
            "理由": "相对强势",
            "_debug_reasoning": ["步骤1: RS=1.3 → 强势", "步骤2: 板块同步"]
        },
        {
            "角色": "弹簧猎人",
            "信号": "看涨",
            "置信度": 90,
            "关键事件": ["弹簧成功"],
            "事件验证": True,
            "失败风险": False,
            "理由": "弹簧效应验证成功",
            "_debug_reasoning": ["步骤1: 弹簧成功", "步骤4: 无失败信号"]
        }
    ]


if __name__ == "__main__":
    # 单独测试时使用
    print("总参谋长Agent单独测试")
    print("创建示例专家报告...")
    
    try:
        sample_reports = _create_sample_reports()
        result = run_chief_strategist_agent(sample_reports)
        print(json.dumps(result, ensure_ascii=False, indent=2))
    except Exception as e:
        print(f"执行总参谋长分析时发生错误: {e}")